#!/usr/bin/python
#
#

import sys
import SocketServer
import threading
import argparse
import re
import cgi
from BaseHTTPServer import BaseHTTPRequestHandler,HTTPServer
from SocketServer import ThreadingMixIn
import time


# 
CMD_DESCRIPTIONS = '\
   - support restful-api calls\n\
	- add key/value pair to store\n\
		- retrieve key/value from store\n\
   - recordID : key, data : value\n\
\n'


#
class LocalData(object):
  records = {}
 
class HTTPRequestHandler(BaseHTTPRequestHandler):

  def do_POST(self,need_reinit=False):
    global attr, delay_post_f, delay_post_b, delay_get_f, delay_get_b

    if None != re.search('/api/v1/addrecord/*', self.path):

      # delay
      time.sleep(delay_post_f)

      ctype, pdict = cgi.parse_header(self.headers.getheader('content-type'))
      if ctype == 'application/json':
        length = int(self.headers.getheader('content-length'))
        data = cgi.parse_qs(self.rfile.read(length), keep_blank_values=1)
        recordID = self.path.split('/')[-1]
        LocalData.records[recordID] = data
        print "record added successfully - key: %s, value: %s" % (recordID, data)
      else:
        data = {}

      # delay
      time.sleep(delay_post_b)

      self.send_response(200)
      self.end_headers()
    else:
      self.send_response(403)
      self.send_header('Content-Type', 'application/json')
      self.end_headers()
    return
 
  def do_GET(self):
    global attr, delay_post_f, delay_post_b, delay_get_f, delay_get_b

    if None != re.search('/api/v1/getrecord/*', self.path):

      # delay
      time.sleep(delay_get_f)

      recordID = self.path.split('/')[-1]

      # delay
      time.sleep(delay_get_b)

      if LocalData.records.has_key(recordID):
        self.send_response(200)
        self.send_header('Content-Type', 'application/json')
        self.end_headers()
        self.wfile.write(LocalData.records[recordID])
      else:
        self.send_response(400, 'Bad Request: record not exists')
        self.send_header('Content-Type', 'application/json')
        self.end_headers()
    else:
      self.send_response(403)
      self.send_header('Content-Type', 'application/json')
      self.end_headers()
    return
 
class ThreadedHTTPServer(ThreadingMixIn, HTTPServer):
  allow_reuse_address = True
 
  def shutdown(self):
    self.socket.close()
    HTTPServer.shutdown(self)
 
class SimpleHttpServer():
  def __init__(self, ip, port):
    self.server = ThreadedHTTPServer((ip,port), HTTPRequestHandler)
 
  def start(self):
    self.server_thread = threading.Thread(target=self.server.serve_forever)
    self.server_thread.daemon = True
    self.server_thread.start()
 
  def waitForThread(self):
    self.server_thread.join()
 
  def addRecord(self, recordID, jsonEncodedRecord):
    LocalData.records[recordID] = jsonEncodedRecord
 
  def stop(self):
    self.server.shutdown()
    self.waitForThread()


#
#
# attribute
#   delay=a,b,c,d
#     a : POST forward-path delay
#     b : POST backward-path delay
#     c : GET forward-path delay
#     d : GET backward-path delay
#
attr = '0,0,0,0'
delay_post_f = 0
delay_post_b = 0
delay_get_f = 0
delay_get_b = 0

#delay_post_f = sys.argv[4]
#delay_post_b = sys.argv[5]
#delay_get_f = sys.argv[6]
#delay_get_b = sys.argv[7]

def extract_delay_attributes(argv):
  global attr, delay_post_f, delay_post_b, delay_get_f, delay_get_b
  try:
        attr = argv.split('=')[1]
        delays = attr.split(',')
        try:
                delay_post_f = float(delays[0])
        except:
                delay_post_f = 0
        try:
                delay_post_b = float(delays[1])
        except:
                delay_post_b = 0
        try:
                delay_get_f = float(delays[2])
        except:
                delay_get_f = 0
        try:
                delay_get_b = float(delays[3])
        except:
                delay_get_b = 0
  except:
        pass

def helper(cmd):
	print '\n%s:\n%s\nUsage:\n   %s <ip> <port>\n' % (cmd, CMD_DESCRIPTIONS, cmd)
 

#
# -- main --
#
if __name__=='__main__':
#  parser = argparse.ArgumentParser(description='HTTP Server')
#  parser.add_argument('ip', help='HTTP Server IP')
#  parser.add_argument('port', type=int, help='Listening port for HTTP Server')
#  args = parser.parse_args()

  # check arguments
  for arg in sys.argv:
#	print (arg)
	if arg == '-?' or arg == '-h' or arg == '--help':
		helper(sys.argv[0])
		sys.exit()


  # ip
  try: 
	_ip = sys.argv[1]
#	file=open("delay.txt","r")
#        _ip = file.read()
#        file.close()
  except IndexError:
	_ip = "127.0.0.1"

  # port
  try: 
	_port = int(sys.argv[2])
  except IndexError:
	_port = 8001
  print "=> web+db ip: %s, port: %d" % (_ip, _port)

  #
  # attributes
  #
  # delay
  try:
	extract_delay_attributes(sys.argv[3])
  except:
	pass
  print '=> delay: %s,%s,%s,%s' % (delay_post_f, delay_post_b, delay_get_f, delay_get_b)

#  sys.exit()


  print 'HTTP Server Running (ip: %s, port: %d)...' % (_ip, _port)

# this will cause server only stoppable by "CTRL+Z/kill <pid>"
#  server = SimpleHttpServer(_ip, _port)
#  server.start()
#  server.waitForThread()

  handler = HTTPRequestHandler
  httpd = SocketServer.TCPServer(("", _port), handler)
  httpd.serve_forever()

